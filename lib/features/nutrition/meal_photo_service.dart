import 'dart:io';
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:image_picker/image_picker.dart';
import 'package:http/http.dart' as http;
import 'package:fitai/features/nutrition/data/nutrition_repository.dart';

class MealPhotoService {
  static const String _apiKey = 'YOUR_VISION_API_KEY'; // Replace with actual API key
  static const String _visionApiUrl = 'https://vision.googleapis.com/v1/images:annotate';
  
  final ImagePicker _picker = ImagePicker();

  /// Captures a photo from camera or selects from gallery
  Future<XFile?> capturePhoto({ImageSource source = ImageSource.camera}) async {
    try {
      final XFile? image = await _picker.pickImage(
        source: source,
        imageQuality: 80,
        maxWidth: 1024,
        maxHeight: 1024,
      );
      return image;
    } catch (e) {
      debugPrint('Error capturing photo: $e');
      return null;
    }
  }

  /// Analyzes the meal photo and extracts food information
  Future<List<MealAnalysisResult>> analyzeMealPhoto(XFile imageFile) async {
    try {
      // Convert image to base64
      final bytes = await imageFile.readAsBytes();
      final base64Image = base64Encode(bytes);

      // For demo purposes, we'll simulate AI analysis with mock data
      // In a real implementation, you would call Google Vision API or similar
      await Future.delayed(const Duration(seconds: 2)); // Simulate API call
      
      // Mock analysis results - in reality this would come from AI
      return _getMockAnalysisResults();
      
      // Uncomment below for real Google Vision API implementation:
      // return await _callVisionAPI(base64Image);
    } catch (e) {
      debugPrint('Error analyzing meal photo: $e');
      throw Exception('Failed to analyze meal photo: $e');
    }
  }

  /// Mock analysis results for demonstration
  List<MealAnalysisResult> _getMockAnalysisResults() {
    return [
      MealAnalysisResult(
        foodName: 'Grilled Chicken Breast',
        confidence: 0.92,
        estimatedWeight: 150,
        calories: 231,
        proteinG: 43.5,
        carbsG: 0,
        fatG: 5.0,
      ),
      MealAnalysisResult(
        foodName: 'Steamed Broccoli',
        confidence: 0.88,
        estimatedWeight: 100,
        calories: 34,
        proteinG: 2.8,
        carbsG: 7.0,
        fatG: 0.4,
      ),
      MealAnalysisResult(
        foodName: 'Brown Rice',
        confidence: 0.85,
        estimatedWeight: 80,
        calories: 111,
        proteinG: 2.6,
        carbsG: 23.0,
        fatG: 0.9,
      ),
    ];
  }

  /// Real Google Vision API implementation (commented out)
  /*
  Future<List<MealAnalysisResult>> _callVisionAPI(String base64Image) async {
    final request = {
      'requests': [
        {
          'image': {'content': base64Image},
          'features': [
            {'type': 'LABEL_DETECTION', 'maxResults': 10},
            {'type': 'OBJECT_LOCALIZATION', 'maxResults': 10},
          ],
        }
      ]
    };

    final response = await http.post(
      Uri.parse('$_visionApiUrl?key=$_apiKey'),
      headers: {'Content-Type': 'application/json'},
      body: jsonEncode(request),
    );

    if (response.statusCode == 200) {
      final data = jsonDecode(response.body);
      return _parseVisionResponse(data);
    } else {
      throw Exception('Vision API error: ${response.statusCode}');
    }
  }

  List<MealAnalysisResult> _parseVisionResponse(Map<String, dynamic> response) {
    // Parse Google Vision API response and convert to MealAnalysisResult
    // This would involve mapping detected labels to nutritional data
    // Implementation depends on your specific needs
    return [];
  }
  */
}

class MealAnalysisResult {
  final String foodName;
  final double confidence;
  final int estimatedWeight; // in grams
  final int calories;
  final double proteinG;
  final double carbsG;
  final double fatG;

  MealAnalysisResult({
    required this.foodName,
    required this.confidence,
    required this.estimatedWeight,
    required this.calories,
    required this.proteinG,
    required this.carbsG,
    required this.fatG,
  });

  /// Convert to NutritionEntry for saving to database
  NutritionEntry toNutritionEntry(String userId) {
    return NutritionEntry(
      id: '', // Will be generated by database
      userId: userId,
      foodName: foodName,
      calories: calories,
      proteinG: proteinG.round(),
      carbsG: carbsG.round(),
      fatG: fatG.round(),
      time: DateTime.now(),
    );
  }

  String _getCurrentMealType() {
    final hour = DateTime.now().hour;
    if (hour < 11) return 'Breakfast';
    if (hour < 15) return 'Lunch';
    if (hour < 19) return 'Dinner';
    return 'Snack';
  }
}

/// Screen for displaying meal photo analysis results
class MealPhotoAnalysisScreen extends StatefulWidget {
  final XFile imageFile;
  final List<MealAnalysisResult> analysisResults;
  final Function(List<NutritionEntry>) onSaveEntries;

  const MealPhotoAnalysisScreen({
    super.key,
    required this.imageFile,
    required this.analysisResults,
    required this.onSaveEntries,
  });

  @override
  State<MealPhotoAnalysisScreen> createState() => _MealPhotoAnalysisScreenState();
}

class _MealPhotoAnalysisScreenState extends State<MealPhotoAnalysisScreen> {
  late List<bool> _selectedItems;
  bool _isSaving = false;

  @override
  void initState() {
    super.initState();
    _selectedItems = List.filled(widget.analysisResults.length, true);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Meal Analysis'),
        actions: [
          TextButton(
            onPressed: _isSaving ? null : _saveSelectedEntries,
            child: _isSaving
                ? const SizedBox(
                    width: 16,
                    height: 16,
                    child: CircularProgressIndicator(strokeWidth: 2),
                  )
                : const Text('Save'),
          ),
        ],
      ),
      body: Column(
        children: [
          // Image preview
          Container(
            height: 200,
            width: double.infinity,
            margin: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(12),
              image: DecorationImage(
                image: FileImage(File(widget.imageFile.path)),
                fit: BoxFit.cover,
              ),
            ),
          ),
          // Analysis results
          Expanded(
            child: ListView.builder(
              padding: const EdgeInsets.all(16),
              itemCount: widget.analysisResults.length,
              itemBuilder: (context, index) {
                final result = widget.analysisResults[index];
                return Card(
                  margin: const EdgeInsets.only(bottom: 12),
                  child: CheckboxListTile(
                    value: _selectedItems[index],
                    onChanged: (value) {
                      setState(() {
                        _selectedItems[index] = value ?? false;
                      });
                    },
                    title: Text(
                      result.foodName,
                      style: const TextStyle(fontWeight: FontWeight.w500),
                    ),
                    subtitle: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text('Confidence: ${(result.confidence * 100).toInt()}%'),
                        Text('Weight: ${result.estimatedWeight}g'),
                        const SizedBox(height: 4),
                        Row(
                          children: [
                            _buildNutrientChip('${result.calories} cal', Colors.orange),
                            const SizedBox(width: 8),
                            _buildNutrientChip('${result.proteinG.toStringAsFixed(1)}g protein', Colors.red),
                            const SizedBox(width: 8),
                            _buildNutrientChip('${result.carbsG.toStringAsFixed(1)}g carbs', Colors.blue),
                          ],
                        ),
                      ],
                    ),
                    isThreeLine: true,
                  ),
                );
              },
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildNutrientChip(String label, Color color) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: color.withOpacity(0.3)),
      ),
      child: Text(
        label,
        style: TextStyle(
          fontSize: 12,
          color: color,
          fontWeight: FontWeight.w500,
        ),
      ),
    );
  }

  Future<void> _saveSelectedEntries() async {
    setState(() {
      _isSaving = true;
    });

    try {
      final selectedResults = <MealAnalysisResult>[];
      for (int i = 0; i < widget.analysisResults.length; i++) {
        if (_selectedItems[i]) {
          selectedResults.add(widget.analysisResults[i]);
        }
      }

      // Convert to nutrition entries (userId will be set by the calling screen)
      final entries = selectedResults.map((result) => result.toNutritionEntry('')).toList();
      
      widget.onSaveEntries(entries);
      
      if (mounted) {
        Navigator.of(context).pop();
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Added ${selectedResults.length} food items'),
            backgroundColor: Colors.green,
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error saving entries: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isSaving = false;
        });
      }
    }
  }
}